{"version":3,"file":"workbox-window.prod.umd.js","sources":["../_version.mjs","../messageSW.mjs","../../workbox-core/_version.mjs","../../workbox-core/_private/Deferred.mjs","../utils/urlsMatch.mjs","../utils/WorkboxEvent.mjs","../Workbox.mjs","../utils/EventTargetShim.mjs"],"sourcesContent":["try{self['workbox:window:4.0.0-rc.2']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport './_version.mjs';\n\n\n/**\n * Sends a data object to a service worker via `postMessage` and resolves\n * and resolves with a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n *\n * @memberof module:workbox-window\n */\nconst messageSW = (sw, data) => {\n  return new Promise((resolve) => {\n    let messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = (evt) => resolve(evt.data);\n    sw.postMessage(data, [messageChannel.port2]);\n  });\n};\n\nexport {messageSW};\n","try{self['workbox:core:4.0.0-rc.2']&&_()}catch(e){}// eslint-disable-line","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nexport class Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nconst urlsMatch = (url1, url2) => {\n  return new URL(url1, location).href === new URL(url2, location).href;\n};\n\nexport {urlsMatch};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nclass WorkboxEvent {\n  /**\n   * @param {string} type\n   * @param {Object} props\n   */\n  constructor(type, props) {\n    Object.assign(this, props, {type});\n  }\n}\n\nexport {WorkboxEvent};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport {Deferred} from 'workbox-core/_private/Deferred.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {messageSW} from './messageSW.mjs';\nimport {EventTargetShim} from './utils/EventTargetShim.mjs';\nimport {urlsMatch} from './utils/urlsMatch.mjs';\nimport {WorkboxEvent} from './utils/WorkboxEvent.mjs';\nimport './_version.mjs';\n\n\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @memberof module:workbox-window\n */\nclass Workbox extends EventTargetShim {\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n  constructor(scriptURL, registerOptions = {}) {\n    super();\n\n    this._scriptURL = scriptURL;\n    this._registerOptions = registerOptions;\n    this._updateFoundCount = 0;\n\n    // Deferreds we can resolve later.\n    this._swDeferred = new Deferred();\n    this._activeDeferred = new Deferred();\n    this._controllingDeferred = new Deferred();\n\n    // Bind event handler callbacks.\n    this._onMessage = this._onMessage.bind(this);\n    this._onStateChange = this._onStateChange.bind(this);\n    this._onUpdateFound = this._onUpdateFound.bind(this);\n    this._onControllerChange = this._onControllerChange.bind(this);\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n  async register({immediate = false} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._registrationTime) {\n        logger.error('Cannot re-register a Workbox instance after it has ' +\n            'been registered. Create a new instance instead.');\n        return;\n      }\n    }\n\n    if (!immediate && document.readyState !== 'complete') {\n      await new Promise((res) => addEventListener('load', res));\n    }\n\n    // Before registering, attempt to determine if a SW is already controlling\n    // the page, and if that SW script (and version, if specified) matches this\n    // instance's script.\n    this._compatibleControllingSW = this._getControllingSWIfCompatible();\n\n    this._registration = await this._registerScript();\n\n    // Only resolve deferreds now if we know we have a compatible controller.\n    if (this._compatibleControllingSW) {\n      this._sw = this._compatibleControllingSW;\n      this._swDeferred.resolve(this._compatibleControllingSW);\n      this._activeDeferred.resolve(this._compatibleControllingSW);\n      this._controllingDeferred.resolve(this._compatibleControllingSW);\n\n      this._reportWindowReady(this._compatibleControllingSW);\n      this._compatibleControllingSW.addEventListener(\n          'statechange', this._onStateChange, {once: true});\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Successfully registered service worker.', this._scriptURL);\n\n      if (navigator.serviceWorker.controller) {\n        if (this._compatibleControllingSW) {\n          logger.debug('A service worker with the same script URL ' +\n              'is already controlling this page.');\n        } else {\n          logger.debug('A service worker with a different script URL is ' +\n              'currently controlling the page. The browser is now fetching ' +\n              'the new script now...');\n        }\n      }\n\n      // If there's an active and waiting service worker before the\n      // `updatefound` event fires, it means there was a waiting service worker\n      // in the queue before this one was registered.\n      if (this._registration.waiting && this._registration.active) {\n        logger.warn('A service worker was already waiting to activate ' +\n            'before this script was registered...');\n      }\n\n      const currentPageIsOutOfScope = () => {\n        const scopeURL = new URL(\n            this._registerOptions.scope || this._scriptURL, document.baseURI);\n        const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n        return !location.pathname.startsWith(scopeURLBasePath);\n      };\n      if (currentPageIsOutOfScope()) {\n        logger.warn('The current page is not in scope for the registered ' +\n            'service worker. Was this a mistake?');\n      }\n    }\n\n    this._registration.addEventListener('updatefound', this._onUpdateFound);\n    navigator.serviceWorker.addEventListener(\n        'controllerchange', this._onControllerChange, {once: true});\n\n    // Add message listeners.\n    if ('BroadcastChannel' in self) {\n      this._broadcastChannel = new BroadcastChannel('workbox');\n      this._broadcastChannel.addEventListener('message', this._onMessage);\n    }\n    navigator.serviceWorker.addEventListener('message', this._onMessage);\n\n    return this._registration;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is active. If a service worker was already controlling at registration\n   * time then it will resolve to that if the script URLs (and optionally\n   * script versions) match, otherwise it will wait until an update is found\n   * and activates.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get active() {\n    return this._activeDeferred.promise;\n  }\n\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is controlling the page. If a service worker was already controlling at\n   * registration time then it will resolve to that if the script URLs (and\n   * optionally script versions) match, otherwise it will wait until an update\n   * is found and starts controlling the page.\n   * Note: the first time a service worker is installed it will active but\n   * not start controlling the page unless `clients.claim()` is called in the\n   * service worker.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  get controlling() {\n    return this._controllingDeferred.promise;\n  }\n\n  /**\n   * Resolves with a reference to a service worker that matches the script URL\n   * of this instance, as soon as it's available.\n   *\n   * If, at registration time, there’s already an active service worker with a\n   * matching script URL, that will be what is resolved. If there’s no active\n   * and matching service worker at registration time then the promise will\n   * not resolve until an update is found and starts installing, at which\n   * point the installing service worker is resolved.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  async getSW() {\n    return this._swDeferred.promise;\n  }\n\n  /**\n   * Sends the passed data object to the service worker registered by this\n   * instance and resolves with a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will never\n   * resolve.\n   *\n   * @param {Object} data An object to send to the service worker\n   * @return {Promise<Object>}\n   */\n  async messageSW(data) {\n    const sw = await this.getSW();\n    return new Promise((resolve) => {\n      let messageChannel = new MessageChannel();\n      messageChannel.port1.onmessage = (evt) => resolve(evt.data);\n      sw.postMessage(data, [messageChannel.port2]);\n    });\n  }\n\n  /**\n   * Checks for a service worker already controlling the page and returns\n   * it if its script URL (and optionally script version) match. The\n   * script version is determined by sending a message to the controlling\n   * service worker and waiting for a response. If no response is returned\n   * the service worker is assumed to not have a version.\n   *\n   * @private\n   * @return {ServiceWorker|undefined}\n   */\n  _getControllingSWIfCompatible() {\n    const controller = navigator.serviceWorker.controller;\n\n    if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n      // If the URLs match and no script version is specified, assume the\n      // SW is the same. NOTE: without a script version, this isn't a\n      // particularly good test. Using a script version is encouraged if\n      // you need to send messages to your service worker on all page loads.\n      return controller;\n    }\n  }\n\n  /**\n   * Registers a service worker for this instances script URL and register\n   * options and tracks the time registration was complete.\n   *\n   * @private\n   */\n  async _registerScript() {\n    try {\n      const reg = await navigator.serviceWorker.register(\n          this._scriptURL, this._registerOptions);\n\n      // Keep track of when registration happened, so it can be used in the\n      // `this._onUpdateFound` heuristic. Also use the presence of this\n      // property as a way to see if `.register()` has been called.\n      this._registrationTime = performance.now();\n\n      return reg;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(error);\n      }\n      // Re-throw the error.\n      throw error;\n    }\n  }\n\n\n  /**\n   * Sends a message to the passed service worker that the window is ready.\n   *\n   * @param {ServiceWorker} sw\n   * @private\n   */\n  _reportWindowReady(sw) {\n    messageSW(sw, {\n      type: 'WINDOW_READY',\n      meta: 'workbox-window',\n    });\n  }\n\n  /**\n   * @private\n   */\n  _onUpdateFound() {\n    const installingSW = this._registration.installing;\n\n    // If the script URL passed to `navigator.serviceWorker.register()` is\n    // different from the current controlling SW's script URL, we know any\n    // successful registration calls will trigger an `updatefound` event.\n    // But if the registered script URL is the same as the current controlling\n    // SW's script URL, we'll only get an `updatefound` event if the file\n    // changed since it was last registered. This can be a problem if the user\n    // opens up the same page in a different tab, and that page registers\n    // a SW that triggers an update. It's a problem because this page has no\n    // good way of knowing whether the `updatefound` event came from the SW\n    // script it registered or from a registration attempt made by a newer\n    // version of the page running in another tab.\n    // To minimize the possibility of a false positive, we use the logic here:\n    let updateLikelyTriggeredExternally =\n        // Since we enforce only calling `register()` once, and since we don't\n        // add the `updatefound` event listener until the `register()` call, if\n        // `_updateFoundCount` is > 0 then it means this method has already\n        // been called, thus this SW must be external\n        this._updateFoundCount > 0 ||\n        // If the script URL of the installing SW is different from this\n        // instance's script URL, we know it's definitely not from our\n        // registration.\n        !urlsMatch(installingSW.scriptURL, this._scriptURL) ||\n        // If all of the above are false, then we use a time-based heuristic:\n        // Any `updatefound` event that occurs long after our registration is\n        // assumed to be external.\n        (performance.now() >\n            this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?\n                // If any of the above are not true, we assume the update was\n                // triggered by this instance.\n                true : false;\n\n    if (updateLikelyTriggeredExternally) {\n      this._externalSW = installingSW;\n      this._registration.removeEventListener(\n          'updatefound', this._onUpdateFound);\n    } else {\n      // If the update was not triggered externally we know the installing\n      // SW is the one we registered, so we set it.\n      this._sw = installingSW;\n      this._swDeferred.resolve(installingSW);\n\n      // The `installing` state isn't something we have a dedicated\n      // callback for, but we do log messages for it in development.\n      if (process.env.NODE_ENV !== 'production') {\n        if (navigator.serviceWorker.controller) {\n          logger.log('Updated service worker found. Installing now...');\n        } else {\n          logger.log('Service worker is installing...');\n        }\n      }\n    }\n\n    // Increment the `updatefound` count, so future invocations of this\n    // method can be sure they were triggered externally.\n    ++this._updateFoundCount;\n\n    // Add a `statechange` listener regardless of whether this update was\n    // triggered externally, since we have callbacks for both.\n    installingSW.addEventListener('statechange', this._onStateChange);\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onStateChange(originalEvent) {\n    const sw = originalEvent.target;\n    const {state} = sw;\n    const isExternal = sw === this._externalSW;\n    const eventPrefix = isExternal ? 'external' : '';\n\n    this.dispatchEvent(new WorkboxEvent(\n        eventPrefix + state, {sw, originalEvent}));\n\n    if (state === 'installed') {\n      // This timeout is used to ignore cases where the service worker calls\n      // `skipWaiting()` in the install event, thus moving it directly in the\n      // activating state. (Since all service workers *must* go through the\n      // waiting phase, the only way to detect `skipWaiting()` called in the\n      // install event is to observe that the time spent in the waiting phase\n      // is very short.)\n      // NOTE: we don't need separate timeouts for the own and external SWs\n      // since they can't go through these phases at the same time.\n      this._waitingTimeout = setTimeout(() => {\n        // Ensure the SW is still waiting (it may now be redundant).\n        if (state === 'installed' && this._registration.waiting === sw) {\n          this.dispatchEvent(new WorkboxEvent(\n              eventPrefix + 'waiting', {sw, originalEvent}));\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (isExternal) {\n              logger.warn('An external service worker has installed but is ' +\n                  'waiting for this client to close before activating...');\n            } else {\n              logger.warn('The service worker has installed but is waiting ' +\n                  ' for existing clients to close before activating...');\n            }\n          }\n        }\n      }, WAITING_TIMEOUT_DURATION);\n    } else if (state === 'activating') {\n      clearTimeout(this._waitingTimeout);\n      if (!isExternal) {\n        this._activeDeferred.resolve(sw);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      switch (state) {\n        case 'installed':\n          if (isExternal) {\n            logger.warn('An external service worker has installed. ' +\n                'You may want to suggest users reload this page.');\n          } else {\n            logger.log('Registered service worker installed.');\n          }\n          break;\n        case 'activated':\n          if (isExternal) {\n            logger.warn('An external service worker has activated.');\n          } else {\n            logger.log('Registered service worker activated.');\n            if (sw !== navigator.serviceWorker.controller) {\n              logger.warn('The registered service worker is active but ' +\n                  'not yet controlling the page. Reload or run ' +\n                  '`clients.claim()` in the service worker.');\n            }\n          }\n          break;\n        case 'redundant':\n          if (!isExternal) {\n            logger.log('Registered service worker now redundant!');\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onControllerChange(originalEvent) {\n    const sw = this._sw;\n    if (sw === navigator.serviceWorker.controller) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log('Registered service worker now controlling this page.');\n      }\n      this.dispatchEvent(new WorkboxEvent('controlling', {sw, originalEvent}));\n      this._controllingDeferred.resolve(sw);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} originalEvent\n   */\n  _onMessage(originalEvent) {\n    const {data} = originalEvent;\n    this.dispatchEvent(new WorkboxEvent('message', {data, originalEvent}));\n  }\n}\n\nexport {Workbox};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nimport '../_version.mjs';\n\n\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nclass EventTargetShim {\n  /**\n   * Creates an event listener registry\n   */\n  constructor() {\n    // A registry of event types to listeners.\n    this._eventListenerRegistry = {};\n  }\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   */\n  addEventListener(type, listener) {\n    this._getEventListenersByType(type).add(listener);\n  }\n\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   */\n  removeEventListener(type, listener) {\n    this._getEventListenersByType(type).remove(listener);\n  }\n\n  /**\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    event.target = this;\n    this._getEventListenersByType(event.type).forEach(\n        (listener) => listener(event));\n  }\n\n  /**\n   * Returns a Set of listeners associated with the passed event type.\n   * If no handlers have been registered, an empty Set is returned.\n   *\n   * @param {string} type The event type.\n   * @return {Set} An array of handler functions.\n   */\n  _getEventListenersByType(type) {\n    return this._eventListenerRegistry[type] =\n        (this._eventListenerRegistry[type] || new Set());\n  }\n}\n\nexport {EventTargetShim};\n"],"names":["self","_","e","messageSW","sw","data","Promise","resolve","messageChannel","MessageChannel","port1","onmessage","evt","postMessage","port2","Deferred","promise","reject","_this","urlsMatch","url1","url2","URL","location","href","WorkboxEvent","type","props","Object","assign","this","f","args","i","arguments","length","apply","value","then","direct","Workbox","scriptURL","registerOptions","_scriptURL","_registerOptions","_updateFoundCount","_swDeferred","_activeDeferred","_controllingDeferred","_onMessage","bind","_onStateChange","_onUpdateFound","_onControllerChange","register","result","immediate","_compatibleControllingSW","_this2","_getControllingSWIfCompatible","_registerScript","_registration","_sw","_reportWindowReady","addEventListener","once","navigator","serviceWorker","_broadcastChannel","BroadcastChannel","document","readyState","res","body","getSW","controller","recover","_this5","reg","_registrationTime","performance","now","error","meta","installingSW","installing","_externalSW","removeEventListener","originalEvent","target","state","isExternal","eventPrefix","dispatchEvent","_waitingTimeout","setTimeout","_this6","waiting","clearTimeout","_eventListenerRegistry","listener","_getEventListenersByType","add","remove","event","forEach","Set"],"mappings":"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"}